#!/usr/bin/env python

import os, sys
import random
import argparse

__version__ = "1.1.0"

parser = argparse.ArgumentParser()
parser.add_argument('input', nargs='?', help='Input file')
parser.add_argument('output', nargs='?', help='Output file (defaults to [filename]-out.vhdl)')
parser.add_argument('-D', '--define', action='append', metavar='LABEL=VALUE', help='Define a label as a given value')
parser.add_argument('-l', '--listppd', action='store_true', help='Print preprocessing directives')
parser.add_argument('-v', action='store_true', help='Verbose output')
parser.add_argument('--version', action='version', version=f"%(prog)s {__version__}")
args = parser.parse_args()

if args.listppd:
    print("test")
    exit(0)
elif args.input is None:
    print("Error: Input file is required")
    exit(1)

# insert an '-out' just before the extension if no specific output file given
if args.output is None:
    ext = os.path.splitext(args.input)
    args.output = ''.join((ext[:-1][0], "-out" + ext[-1]))

if args.v:
    print("Input file:", args.input)
    print("Output file:", args.output)

try:
    infile = open(args.input, 'r')
    intext = infile.read().split('\n')[:-1]
except Exception as e:
    print(e)
    exit(1)

inpath = '/'.join(args.input.split('/')[:-1])
print(inpath)

# Append comment char to line when true
commentflag = False
forline = None
forcount = -1

definitions = {}

if args.define is not None:
    for d in args.define:
        definitions[d.split('=')[0]] = d.split('=')[1]

for iter in range(len(intext[:])):
    line = intext[iter].strip()

    # Check if opening comment in line
    if "/*" in line:
        commentflag = True

    if commentflag:
        intext[iter] = '-- ' + intext[iter]

    # Check if closing comment in line
    if "*/" in line:
        commentflag = False

    if len(line) < 1:
        # print("Skipping empty line")
        continue

    # Check for preprocessor functions
    if '`' == line[0]:
        instr = line[1:].split(' ')
        intext[iter] = '-- ' + intext[iter]
        if instr[0] == 'include':
            print("Including", instr[1])
            inclfile = open(inpath + "/" + instr[1].replace('"',''), 'r')
            incltext = inclfile.read()
            intext.insert(iter + 1, incltext)
        elif instr[0] == 'define':
            if len(instr) == 3:
                print("Defining", instr[1], "as", instr[2])
                definitions[instr[1]] = instr[2]
            elif len(instr) == 2:
                print("Defining", instr[1])
                definitions[instr[1]] = None
        elif instr[0] == 'rand':
            pass
        elif instr[0] == 'undef':
            pass
        elif instr[0] == 'ifdef':
            pass
        elif instr[0] == 'ifndef':
            pass
        elif instr[0] == 'elif':
            pass
        elif instr[0] == 'else':
            pass
        elif instr[0] == 'endif':
            pass
        elif instr[0] == 'for':
            forline = iter
            forcount = int(instr[1])
            pass
        elif instr[0] == 'endfor':
            print(intext[forline+1:iter])
            incltext = ''
            for j in range(forcount - 1):
                if j != 0:
                    incltext = incltext + '\n--\n' + '\n'.join(intext[forline+1:iter])
                else:
                    incltext = incltext + '--\n' + '\n'.join(intext[forline+1:iter])
            intext.insert(iter, incltext)
            pass
        elif instr[0] == 'message':
            print("Message:", ' '.join(instr[1:]))
        else:
            print("Unknown directive:", instr[0])

    # Skip commented and preprocessor lines
    if "--" == line[:2] or '`' == line[0]:
        # print("Skipping commented/preproc line")
        continue

    for word in line.split(' '):
        if word in definitions and definitions[word] is not None:
            # print("Replacing", word, "with", definitions[word], ": ", intext[iter])
            intext[iter] = intext[iter].replace(word, definitions[word])

for line in intext[:]:
    print(line)
